.. _architecture:

架构概况
======================

我们喜欢花一些时间来解释我们是如何设计 Kivy 框架的，
从软件工程的角度来说明。这是理解 Kivy 是如何工作的关键点。
如果你只看代码的话，各种各样的写法会让你感到思路混乱，
这对大多数用户来说都会因产生恐惧而失去阅读的兴趣。
本篇文档就是解释一下实现 Kivy 框架的基础思路，涉及更多细节。
你可以跳过这部分，稍后再看也可以，但我们建议至少要了解概况中的内容。

Kivy 的组成简言之是由许多块搭建起来的。下面是架构的一个汇总图示：

.. image:: ../images/architecture.png
    :align: center

.. _providers:

内核与输入供应器
----------------------------------

理解 Kivy 的内幕是一个关键思路，因为内部都是模块化和抽象的过程。
我们尽力提取出基础部分，例如打开一个窗口显示图片和文本，播放音频，
从摄像头获得图像，拼写纠错，等等任务。我们把这些都叫做 *内核* 任务。
有了内核就可以让 API 简单实用了，并且可以扩展 API。最重要的就是
内核允许我们使用所说的具体供应器，每个供应器都是支持着应用运行中各自的情景。
例如，在 OSX, Linux 和 Windows 三大操作系统上，原生的 APIs 对不同的
内核任务都是不一样的。针对不同操作系统都是不同的代码片段支持着具体的
APIs 与每个操作系统进行单向通信。并且与 Kivy 的通信是在另一边（扮演
了一种中间通信层），我们叫它 *内核供应器*。
使用特殊的内核供应器，对于每种操作系统来说都是有优势的，因为我们可以
完全平衡操作系统曝光的功能，并且尽可能有效率地执行。
内核也让用户自行选择。更进一步来说，通过使用一些针对一个操作系统而
移植的库，我们有效地减小了 Kivy 应用的分发体积，并且打包更容易了。
这也让 Kivy 程序变成任何一个操作系统上的应用更加容易。移植成安卓应用
在这里得到了很棒的好处。

我们遵循了相同的输入处理概念。*输入供应器* 就是一段代码，它增加了对
具体输入设备的支持，例如，苹果的触摸板，TUIO 或 一个鼠标模拟器。
如果你需要增加新的输入设备支持，你可以直接写一个新类，用这个新类来
读取输入数据后把输入数据转换成 Kivy 的基础事件。


显卡
--------

Kivy 的显卡 API 是我们的 OpenGL 抽象部署。在最底层上，
Kivy 释放了硬件加速，使用 OpenGL 来实现绘制命令。在写
OpenGL 代码时，不管如何做到的，对于新手来说会有一点稀里糊涂。
这也就是为什么我们要提供显卡 API 给用户，让你们绘图时直接使用
而这些用法实际上在 OpenGL 驱动里并不存在（例如Canvas、Rectangle等等）。

我们所有的挂件自身也是使用显卡 API 来实现，因为 API 是用 C 语言写的，
因为只有 C 语言可以直接识别硬件。

另外显卡 API 的优势还有其自身自动优化的能力，你写的 Python 代码自动
优化成驱动绘制命令。这是特别有帮助的，因为如果你不是硬件 OpenGL 专家的话，
在微调硬件上就是一筹莫展。而 Kivy 的显卡 API 给 Python 提供了更效率地绘制能力。

当然你可以继续使用原始的 OpenGL 命令，如果你熟悉的话。显卡驱动的版本是
 OpenGL 2.0 ES (GLES2) ，这会作用在所有显卡上，所以如果你想要保持跨
平台的兼容能力，我们建议你只使用这个 GLES2 驱动提供的函数。


内核
----

在内核包中的代码提供了共性，例如：

    Clock
        时钟是你用来安排事件什么时候发生的。同时支持一次性和周期性事件时钟设置。

    Cache
        如果你需要缓存你经常用的事物，你可以使用我们的类，这样就不用你自己再写了。

    Gesture Detection
        我们直接把手势识别集成在一起，你可以用来检测各种触摸屏上的操作。
        例如，用手指画圆或四边形。你也可以用你自己的手势来训练手势检测器。

    Kivy Language
        我们提供了 kivy 语言接口给用户，这是一种外观设计语言，对用户来说简单实用并有效率。

    Properties
        Kivy 中没有 Python 语言里的那些属性值。这里有我们自己的属性类，
        这些属性类把你的挂件代码连接到用户接口描述上。


UIX (挂件与图层的合称)
-----------------------

在 uix 包中含有共性的挂件和图层类，这都是你可以重复使用来快速建立用户接口的。

    Widgets
        挂件类都是用户接口元素，也就是要用在你的应用程序中提供一些功能。
        其中有些类是可见的，有的不是。例如一个文件浏览器、按钮、滑条、列表，
        等等功能。挂件类是可以接收运动事件类的。

    Layouts
        图层是你用来布置挂件用的。当然需要你自己计算挂件的位置坐标了，
        但常常可以使用我们已经提供给你的一种便利图层。例如，网格图层、
        盒子图层。你也可以使用嵌入图层方式来布置。


模块
-------

如果你曾经用过一段时间现代网页浏览器的话，你知道可以用一些插件来自定义浏览器。
那么你理解我们的模块类就容易了，这就是我们模块背后的基础思路。
`modules` 包中的模块都是用来把功能插入到 Kivy 程序中的，
如果程序的原作者缺少一个功能，你也可以为程序增加一个功能。

例如，一个模块可以把当前应用的 FPS 值显示在屏幕上，这样你就可以了解
显卡绘制图像时的 FPS 值情况。

你也可以写自己的模块类。


输入事件 (触摸)
----------------------

Kivy 提取了不同的输入类型和资源，例如，touches, mice, TUIO 或类似东西。
所有这些输入类型的共性是什么？那就是你可以访问一种 2D 屏幕上的坐标点，含有
每个独立的输入事件。（也有一些其它的输入设备，例如，加速器对你来说不能容易
找到设备倾斜时的一个 2D 坐标点。这种类型的输入是单独进行处理的。）

所有这些输入类型都呈现在 Touch() 类的实例中。（注意这里的类名不单是用手指
触摸的意思，包括所有其它类型。我们这里命名成 *Touch* 是为了简化的目的。
可以理解成用户可以触及到的许多设备接口或屏幕。）一个触碰实例，或对象，都可以
位于三种状态。当一个触碰动作进入了这些状态中的一种时，你的程序就会知道有事发生了。
触碰动作的三个状态是：

    Down
        只按下一次的动作状态，即第一次出现触碰动作的时刻。
    Move
        一种潜在的无限次数的触碰动作。
        一种触碰中不会被迫进入本状态的动作。例如，长按着不放。
        一种触碰的 2D 坐标点变化时的运动。例如，滑动动作。
    Up
        一种最多抬起一次的触碰动作，不会有第二次抬起。例如，松开按键。
        实际中你几乎一直接收一种向上事件，因为不碰键盘的时候，或不碰屏幕的时候都是
        这种情况，但也不是一定的事情。如果你知道你的用户会使用的输入源头，你会知道
        这种状态是否会有变化。


挂件与事件调度
-----------------------------

术语*挂件*常常会用在 GUI 编程语境中，是用来描述程序的某一个部分，
这个部分就是用户与之互动的对象。在 Kivy 中，一个挂件就是一个接收
输入事件的对象。不是非要显示在屏幕上的。所有挂件都放置在一个*挂件树*上
（就像圣诞节的圣诞树，不过是一颗数据结构树，这是计算机科学中的一个分支
课程）：一个挂件可以有任何数量的子挂件，或者什么也没有。但却总有一个
*根挂件*在树的顶端，根挂件之上就再没有父挂件了，并且所有其它的挂件
都是根挂件的直接或间接子挂件（这就是著名的树倒栽存活理论，所以叫根）。

当新的输入数据可用的时候，Kivy 会发送出一个触碰一个事件信号。
挂件树的根挂件是第一个收到这种事件的对象。根据触碰的状态，
 on_touch_down, on_touch_move 或 on_touch_up 三个事件
都会调度（把触碰状态作为参数）给根挂件，根挂件相应的三个事件处理器
就会被调用而产生结果。

树上的每个挂件（包括根挂件）即可以选择自行消化事件，也可以选择传递事件。
如果一个事件处理器返回结果是 `True` 的话，意思就是事件已经被自行消化后
正确地处理完毕。这个事件不会再有下一步处理。否则，事件处理器会把挂件传递
给自身的子挂件，这是需要调用自身的各自事件处理的上级类实现的。这种情况会
向上传递给基类 `Widget` 类，在自身的触碰事件处理器中，什么也不做，只是
把触碰状态传递给自身子挂件::

    # This is analogous for move/up:
    def on_touch_down(self, touch):
        for child in self.children[:]:
            if child.dispatch('on_touch_down', touch):
                return True

这要比第一次看起来更容易些。这个例子如何用来建立一个良好的应用，我们会
在后面的文档中给出介绍。

常常你会需要在屏幕上限制这种*区域*，例如一个看守触碰状态的挂件。
你可以使用一个挂件的 collide_point() 方法来实现这个目的。
你直接把触碰的位置坐标传递给挂件，然后如果触碰在这个区域内的话，
挂件返回 `True` 值，否则返回 `False` 值。默认情况，这种检查
区域是屏幕上的四边形，通过挂件的 `pos` 描述的坐标值（x和y坐标值），
还有挂件的 `size` （宽和高），但你也可以在自己的类中覆写这种行为。

